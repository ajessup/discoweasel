#include <stdbool.h>
#include "TExaS.h"

/**
 * When we interact with GPIO pins, we do so by addressing a special set of
 * addresses of the chipset's RAM. These can be read from or written to like
 * actual RAM when configured accordingly, but are *not* actual RAM.
 *
 * This block defines a series of constants to represent particular memory
 * addresses. 
 */

// Registers for Port F

// Port F has 5 pins. In GPIO mode, these pins are tied to specific hardware
// on the LaunchPad. 
//
// PF0 is wired to switch 1 (neg. logic, so PUR must also be set)
// PF4 is wired to to swtich 2 (neg. logic, so PUR must also be set)
//  ie. set bits 0 and 4 in GPIO_PORTF_PUR_R
// PF1 is wired to RED LED (should be set to output)
// PF2 is wired to BLUE LED (should be set to output)
// PF3 is wired to GREEN LED (should be set to output)


// Data registers (can be set or read depending of the direction of the pin)
#define GPIO_PORTF_DATA_R       (volatile unsigned long *)0x400253FC

// Port F direction registers (set pin to 0 for input or 1 for output)
// The first bit of this register corresponds to PF0, second bit to PF1 etc.
#define GPIO_PORTF_DIR_R        (*((volatile unsigned long *)0x40025400))

// Alternate function registers ()
#define GPIO_PORTF_AFSEL_R      (*((volatile unsigned long *)0x40025420))

// Enable or disable the pull-up resistors
#define GPIO_PORTF_PUR_R        (*((volatile unsigned long *)0x40025510))

// Enable digital (essentially, which pins we want to turn on for digital IO)
#define GPIO_PORTF_DEN_R        (*((volatile unsigned long *)0x4002551C))

// Enable analog mode for a given pin
#define GPIO_PORTF_AMSEL_R      (*((volatile unsigned long *)0x40025528))

// Set the port control mode
#define GPIO_PORTF_PCTL_R       (*((volatile unsigned long *)0x4002552C))

// ? 
#define SYSCTL_RCGC2_R          (*((volatile unsigned long *)0x400FE108))

#define SYSCTL_RCGC2_GPIOF      0x00000020  // port F Clock Gating Control (6th bit is true)

#define GPIO_PORTF_LOCK_R		(*((volatile unsigned long *)0x40025520))

#define GPIO_PORTF_CR_R			(*((volatile unsigned long *)0x40025524))

// Systick control register
#define NVIC_ST_CTRL_R      	(*((volatile unsigned long *)0xE000E010))

// Systick reload register
#define NVIC_ST_RELOAD_R    	(*((volatile unsigned long *)0xE000E014))

// Systick current value register
#define NVIC_ST_CURRENT_R   	(*((volatile unsigned long *)0xE000E018))

// System control registers
#define SYSCTL_RCC_R
#define SYSCTL_RCC2_R
#define SYSCTL_RIS_R



/**
 * Set up and kick off the systick counter
 */

void init_systick(unsigned long value) {
	NVIC_ST_CTRL_R = 0;              // 1) disable SysTick during setup
	NVIC_ST_RELOAD_R = value;        // 2) set reload value
	NVIC_ST_CURRENT_R = 0;           // 3) any write to current clears it
	NVIC_ST_CTRL_R = 0x00000005;     // 4) enable SysTick with core clock
}

/**
 * Set up the phase-lock-loop to set an accurate system clock
 * This will effecitvely achieve two things. 1/ It will switch the
 * microcontroller to using an external (and more accurate) timing
 * crystal rather than its internal one, and 2/ will allow us to 
 * specify the specific clock frequency
 */

void init_pll() {
	// activate the LM4F123/TM4C123 Launchpad with a 16 MHz main
	// oscillator to run at 80 MHz
	
	// Use RCC2 because it provides more options. See p220 of
	// http://www.ti.com/lit/ds/spms376e/spms376e.pdf
	SYSCTL_RCC2_R |=  0x80000000;
	
	// The first step is to set the BYPASS2 (bit 11) bit. At this point 
	// the PLL is bypassed and there is no system clock divider
	SYSCTL_RCC2_R |=  0x00000800;
	
	// The second step is to specify the crystal frequency in the four
	// XTAL bits using the code in Table 10.1. 
	
	// OSCSRC is the device that chooses which clock to use
	
	// The OSCSRC2 bits are 
	// cleared to select the main oscillator as the oscillator clock source.
	
	SYSCTL_RCC_R = (SYSCTL_RCC_R &~0x000007C0)   // clear XTAL field, bits 10-6
	                 + 0x00000540;   // 10101, configure for 16 MHz crystal
	
	SYSCTL_RCC2_R &= ~0x00000070;  // configure for main oscillator source
	
	// The third step is to clear PWRDN2 (bit 13) to activate the PLL
	SYSCTL_RCC2_R &= ~0x00002000;
	
	// The fourth step is to configure and enable the clock divider 
	// using the 7-bit SYSDIV2 field. If the 7-bit SYSDIV2 is n, then the clock
	// will be divided by n+1. To get the desired 80 MHz from the 400 MHz PLL, we
	// need to divide by 5. So, we place a 4 into the SYSDIV2 field
	
	SYSCTL_RCC2_R |= 0x40000000; 
	SYSCTL_RCC2_R = (SYSCTL_RCC2_R&~ 0x1FC00000)  // clear system clock divider
		                 + (4<<22);      // configure for 80 MHz clock
	
	// The fifth step is to wait for the PLL to stabilize by waiting for PLLRIS
	// (bit 6) in the SYSCTL_RIS_R to become high
	while((SYSCTL_RIS_R&0x00000040)==0){};  // wait for PLLRIS bit
	
	// The last step is to connect/enable the PLL by clearing the BYPASS2 bit
	SYSCTL_RCC2_R &= ~0x00000800;
}

/**
 * Returns the value of the systick reset flag
 */

bool get_systick_reset_flag(void) {
	return ((NVIC_ST_CTRL_R&0x00010000)>>15); // Read the 16th bit
}

/**
 * In this first example we will make PF4 and PF0 input (switches), and we will make PF3 
 * PF2 and PF1 output (LED's). 
 */

void init_portf(void) {
	volatile unsigned long dummy_read;

	/** 
	 * To use a port we first must 
	 * activate its clock in the SYSCTL_RCGC2_R register. If we tried to access the port
	 * without enabling its clock first we'd get a bus error.
	 */

	 SYSCTL_RCGC2_R |= SYSCTL_RCGC2_GPIOF; // Set the sixth bit to true
	 dummy_read = SYSCTL_RCGC2_R;  (void)dummy_read; // Do a dummy read, just to add some clock cyles

	 /** 
	 * The second step is to
	 * unlock the port, by writing a special value to the LOCK register, followed
	 * by setting bits in the CR register.
	 */

     GPIO_PORTF_LOCK_R = 0x4C4F434B; // This special value unlocks the LOCK register
	 // Read more at http://www.ti.com/lit/ds/spms376e/spms376e.pdf page 684
	 
	 /**
	  * CR is the "commit register" which allows to expressly unlock (ie. set values
	  * for) some other important registers below. If a bit in the GPIOCR register is 
	  * set, the data being written to the corresponding bit of the GPIOAFSEL, 
	  * GPIOPUR, GPIOPDR, or GPIODEN registers is committed to the register and 
	  * reflects the new value.
	  * 
	  * Only PF0 on the TM4C needs to be unlocked. All the other bits
	  * on the TM4C are always unlocked. 
	  */
	 
	 GPIO_PORTF_CR_R = 0x1F; // Set the first five bits of the CR reigster

	 /**
	 * The third step is to disable the analog functionality, by clearing bits 
	 * in the AMSEL register. We do this because we're using the port for digital I/O
	 */

    GPIO_PORTF_AMSEL_R = 0x00;

	/** 
	 * The fourth step is to select GPIO/regular digital functionality, 
	 * by clearing bits in the PCTL register, as described in Table 6.1. 
     */
	
	GPIO_PORTF_PCTL_R = 0x00000000;

	/**
	 * The 
	 * fifth step is to specify whether the pin is an input or an output by 
	 * clearing or setting bits in the DIR register. 
	 *
	 * PF4,PF0 in, PF3-1 out
	 */ 
	
	GPIO_PORTF_DIR_R = 0x0E;

	/** 
	 * Because we are using the pins
	 * as regular digital I/O, the sixth step is to clear the corresponding bits in
	 * the AFSEL register. 
	 */

    GPIO_PORTF_AFSEL_R = 0x00; 

	/** 
	 * The last step is to enable the corresponding I/O pins 
	 * by writing ones to the DEN register. 
	 */
	
	GPIO_PORTF_DEN_R = 0x1F; 

	/** 
	 * To run this example on the LaunchPad, 
	 * we also set bits in the PUR register for the two switch inputs (Figure 6.3) 
	 * to have an internal pull-up resistor on PF0 and PF4
	 */
	
	GPIO_PORTF_PUR_R = 0x11; 
}

void set(bool value, unsigned short offset_count, volatile unsigned long *var) {
	unsigned long offset = (0x1 << offset_count);
	if(value){
		*var = *var|offset;
	}else{
		*var = *var&~offset;
	}
}

int main(void) {
	//bool sw1 = false, sw1_prev = false;
	unsigned long flash_count=0;
	bool light_on = true;
	init_portf();
	init_pll();
	init_systick(0xFFFFFF);
	while(1){
		set(light_on, flash_count%3, GPIO_PORTF_DATA_R);
		if(get_systick_reset_flag()) {
			light_on = !light_on;
			flash_count++;
		}
		// sw1 = (*GPIO_PORTF_DATA_R&0x10) >> 4; // read PF4
		// if((sw1 != sw1_prev) && sw1)
		// 	press_count++;
		// sw1_prev = sw1;
		// *GPIO_PORTF_DATA_R = 0x0;
		// set(true, press_count%4, GPIO_PORTF_DATA_R);
		// set(true, press_count%3, GPIO_PORTF_DATA_R);
	}
}




